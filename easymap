#!/usr/bin/env python

# ./easymap -n project_name -w snp -sim -r at -g chr1+4.gff -rs ref -cr bc -co par_mut -sm 600 -sr 0,14-1,31-2,33-3,15-4,5-5,2/0,24-1,42-2,25-3,6-4,1-5,2+1,5860210+100 -ss 25+100,0+500,100+1+50+se
# ./easymap -n ins-test -w ins -sim -r at2 -i at_chloroplast.fa -g chr1+4.gff -sm 10 -ss 15+100,0+500,100+1+50+pe
#
# Recombination frequencies for Arabidopsis thaliana:
# chr1: 0,14-1,31-2,33-3,15-4,5-5,2
# chr2: 0,26-1,42-2,25-3,5-4,1-5,1
# chr3: 0,20-1,39-3,28-4,2-5,1
# chr4: 0,24-1,43-2,25-3,6-4,1-5,1
# chr5: 0,16-1,34-2,31-3,14-4,4-5,1
#
# Explore possibility of condensing the arguments -mb, -cr, -co in a single string (or even to the case number, as described in the documentation):
# ref-bc-parmut, ref-bc-parnomut, ref-bc-f2wt, ref-oc-parmut, ref-oc-parnomut, ref-oc-f2wt
# noref-bc-parmut, noref-bc-parnomut, noref-bc-f2wt, noref-oc-parmut, noref-oc-parnomut, noref-oc-f2wt

import argparse, os, fnmatch, subprocess
from subprocess import call

parser = argparse.ArgumentParser()
parser.add_argument('--usage', '-u', action = 'store_true', dest = 'usage')
parser.add_argument('--project-name', '-n', action = 'store', default = '', dest = 'project_name')
parser.add_argument('--workflow', '-w', action = 'store', default = 'n/p', dest = 'workflow', choices = set(('snp','ins')))
parser.add_argument('--simulate-data', '-sim', action = 'store_true', dest = 'simulate')
parser.add_argument('--reference-sequence', '-r', action = 'store', default = 'n/p', dest = 'ref_seq')
parser.add_argument('--insertion-sequence', '-i', action = 'store', default = 'n/p', dest = 'ins_seq')
parser.add_argument('--gff-file','-g', action = 'store', default = 'n/p', dest = 'gff_file')
parser.add_argument('--annotation-file', '-a', action = 'store', default = 'n/p', dest = 'ann_file')
parser.add_argument('--reads-problem', '-P', action = 'store', default = 'n/p', dest = 'reads_sample')
parser.add_argument('--reads-control','-C', action = 'store', default = 'n/p', dest = 'reads_control')
parser.add_argument('--mutant-background','-mb', action = 'store', default = 'n/p', dest = 'is_ref_strain', choices = set(('ref','noref')))
parser.add_argument('--cross-type', '-cr', action = 'store', default = 'n/p', dest = 'cross_type', choices = set(('oc','bc')))
parser.add_argument('--control-type','-co', action = 'store', default = 'n/p', dest ='control_type', choices = set(('par_mut','par_nomut','f2wt')))
parser.add_argument('--sim-mut', '-sm', action = 'store',default = 'n/p', dest = 'sim_mut')
parser.add_argument('--sim-recsel','-sr', action = 'store', default = 'n/p', dest = 'sim_recsel')
parser.add_argument('--sim-seq', '-ss', action = 'store', default = 'n/p', dest = 'sim_seq')

args = parser.parse_args()


generic_help_message = "Please refer to the documentation for comprehensive help."

if args.usage:
	print "Please see section 'easymap commad line arguments' in the documentation."
	#print "--project_name (-n): name of the project, must not contain any space, if not given, would be <project> as a default.\n--workflow (-w): choose between <snp> or ins depending on whether you desire to run one workflow or another.\n--data_source (-d): it is set  <exp> (experimental) as a default, it can be written with the parameter <sim> if a simulation is intended to be performed. --reference-sequence (-r): please specify the name of the file in user_projects with a <.fa> ending(do not write it with the fa), it is important to give a substring which is identical in the different contig files you may have. --ins_seq(-i): when performing an insertional analysis it is necessary to be given the name of a fasta file containing the insertion or insertional vector which is saved in user_data. --gff_file(-g) please give the name of a gff format file which contain the contigs are going to be analyzed, it should be held in user_projects. --reads_problem(-P): please specify the name of the fastq format reads desired to be analyzed, they must be held in user_projects, if they are pared end reads they should be written with a coma between the read files names <forward_read,reverse_read>.\n--reads-control(-C) please specify the name of the files held in user_projects which are intended to be the control ones (only in snp analysis mode).\n--is_ref_strain(-rs): parameter used in snp mode, it has to options <ref> and <noref> depending on whether the problem population are in the same strain than the reference genome given or not.\n--cross_type (-cr) snp mode parameter that has to be chosen between <oc> meaning outcross and <bc> meaning backcross depending on the experimental design.\ncontrol_type snp mode parameter that specifies if the control used is a parental or a wild type F2 bulk population <f2wt>. If it is "
	quit()

if args.project_name == "n/p":
	project_name = "unnamed_project"
else: project_name = args.project_name

if args.workflow == "n/p":
	print "ERROR: Argument -w/--workflow is required. " + generic_help_message
	quit()
else: workflow = args.workflow

if args.gff_file == "n/p":
	print "ERROR: Argument -g/--gff-file is required. " + generic_help_message
	quit()

if args.ref_seq == "n/p":
	print "ERROR: Argument -r/--reference-sequence is required. " + generic_help_message
	quit()

workflow = args.workflow
gff_file = args.gff_file

# Fill the vaiable data_source with 'sim' or 'exp' depending on whether the user used or not the --simulate/-sim flag
if args.simulate:
	data_source = 'sim'
else:
	data_source = 'exp'

ref_seq = args.ref_seq
ins_seq = args.ins_seq
reads_sample = args.reads_sample
ann_file = args.ann_file
sim_mut = args.sim_mut
sim_recsel = args.sim_recsel
sim_seq = args.sim_seq
control_type = args.control_type
if control_type == "n/p":
	control_parental = "n/p"
	snp_analysis_type = "n/p"
cross_type = args.cross_type
reads_control = args.reads_control
is_ref_strain = args.is_ref_strain
read_s = "n/p"
read_f = "n/p"
read_r = "n/p"
read_s_control = "n/p"
read_f_control = "n/p"
read_r_control = "n/p"
lib_type_control = "n/p"
lib_type_sample = "n/p"
snp_analysis_type = "n/p"

problems = []
error = 0

# Check whether the user has provided a project_name and it has no space:  
is_there_space = project_name.split(" ")
if len(is_there_space) != 1:
	error = 1
	problems.append("Argument -n/--project-name: the name provided cannot contain spaces.")

# Check whether user_data directory exists
input_directory = "./user_data"
if os.path.isdir(input_directory) == False:
	error = 1
	problems.append("The directory /user_data could not be found. Please create it and place your input files inside.")

#THE FOLLOWING LINES ARE DEPRECATED
#else:
#	#Check whether there are reference file/s in 0_input/gnm_ref
#	try:
#		gnm_ref_directory = "./user_data/gnm_ref" #Looks in the path were the file/s should be found
#		if not os.listdir(gnm_ref_directory): #This function creates a list of the items in the specified path. Thus, if no items are found, the result of the function will be FALSE
#		    error = 1
#		    problems.append("The reference file/files should be in the directory " + gnm_ref_directory)
#	except:
#		error = 1
#		problems.append("No directory"+ gnm_ref_directory + " has been found, please create the directory and include the reference genome") 


# Create a list with the names of all the files in the directory user_data
input_files = os.listdir(input_directory)

# Check reference sequence input
# First, check that the user string does not have any spaces or dots in it. We need the basename of the file (basename.fa) or files (1.basename.fa, 2.basename.fa, ...)
# ? Checking for spaces and dots isn't really necessary because any name with these will not match any valid .fa file in the directory /user_data.
fasta_name_has_bad_format = False

if len(ref_seq.split(".")) != 1:
	error = 1
	problems.append("Argument -r/--reference-sequence: the name provided cannot contain dots.")
	fasta_name_has_bad_format = True

if len(ref_seq.split(" ")) != 1:
	error = 1
	problems.append("Argument -r/--reference-sequence: the name provided cannot contain spaces.")
	fasta_name_has_bad_format = True

if fasta_name_has_bad_format == False:
	# Check if there are .fa files in the directory user_data that have the string provided by the user as basename
	refs_in_input_files = fnmatch.filter(input_files, '*'+ref_seq+'.fa') # fnmatch filters a list using a string that accepts wildcards
	refs_in_input_files.sort()
	if not refs_in_input_files:
		error = 1
		problems.append("Argument -r/--reference-sequence: the name provided does not match the basename of any .fa file in the directory /user_data.")

# Check gff file
if gff_file not in input_files:
		error = 1
		problems.append("Argument -g/--gff-file: the name provided does not match any file in the directory /user_data.")

# In case the user decides to give an annotation file, check it.
if ann_file != "n/p":
	if ann_file not in input_files:
		error = 1
		problems.append("Argument -a/--annotation-file: the name provided does not match any file in the directory /user_data.")

#In the analysis mode of snp, cross_type, is_ref_strain and control_parental are required parameters
if workflow == "snp":
	if control_type == "n/p":
		error = 1
		problems.append("Argument -co/--control-type is required.")
	else:
		if control_type == "f2wt": snp_analysis_type = "f2wt"
		else: snp_analysis_type = control_type.split("_")[0]; control_parental = control_type.split("_")[1]

		if snp_analysis_type == "f2wt":
			if cross_type == "oc":
				error = 1
				problems.append("This program does not support the experimental design chosen (-cr/--cross-type = oc and -co/--control-type = f2wt).")
			else:
				cross_type = "bc"
				control_parental = "n/p"
				if data_source == "sim":
					if is_ref_strain == "n/p":
						error = 1
						problems.append("In order to use simulation data of snp with f2wt control line, it is necessary to provide --mutant_background / -mb argument as ref/noref.") #######################################################3
				#else:
				#	is_ref_strain = "n/p"

		if snp_analysis_type == "par":
			if cross_type == "n/p": error = 1; problems.append("Argument -cr/--cross-type is required.")
			if is_ref_strain == "n/p": error = 1; problems.append("Argument -mb/--mutant-background is required.") 
			if control_parental == "n/p": error = 1; problems.append("Argument -co/--control-type is required.") 
			
			if is_ref_strain == "noref" and cross_type == "oc" and control_parental == "nomut":
				error = 1
				problems.append("This program does not support the experimental design specified (-mb/--mutant-background = noref, -cr/--cross-type = oc, -co/--control-type = par_nomut).")
			#if cross_type == "bc" and is_ref_strain =="noref":
			#	error = 1
			#	problems.append("In order to perform a snp analysis having a parental as a control, a backcross analysis requires to be in the reference background.")
			if is_ref_strain == "ref" and cross_type == "bc" and control_parental != "mut":
				error = 1
				problems.append("The experimental design specified (-mb/--mutant-background = ref, -cr/--cross-type = bc, -co/--control-type = par_mut) is impossible.")

#If the analysis mode is insertions, an insertion sequence must be given
if workflow == "ins":
	if ins_seq == "n/p":
		error = 1
		problems.append("Argument -i/--insertion-sequence is required.")
	else:
		if ins_seq not in input_files:
			error = 1
			problems.append("Argument -i/--insertion-sequence: the name provided does not match any file in the directory /user_data.")

#If the user chooses to simulate reads:  
if data_source == "sim":

	# If the user provided a basename that does not match any files, many of the following checks are impossible.
	# Therefore, do the following only if refs_in_input_files is not empty:
	if refs_in_input_files:

		# Function to parse fasta file
		def read_fasta(fp):
			name, seq = None, []
			for line in fp:
				line = line.rstrip()
				if line.startswith('>'):
					if name: yield (name, ''.join(seq))
					name, seq = line, []
				else:
					seq.append(line)
			if name: yield (name, ''.join(seq))

		# Create variable to contain the legth of the genome.
		genome_length = 0

		# This list contains the length of each contig and the total length. The number of elements corresponds to the number of contigs in the genome.
		ref_seq_stats = []

		for contig in refs_in_input_files:
			# Read fasta file
			with open('user_data/' + contig) as fp:
				for name, seq in read_fasta(fp):
					contig_length = len(seq)
					genome_length += contig_length
					ref_seq_stats.append(contig_length)
	
		# Process user input
		if workflow == "snp":
			if sim_mut == "n/p" : error = 1; problems.append("Argument -sm/--sim-mut is required.")
			if sim_recsel == "n/p": error = 1; problems.append("Argument -sr/--sim-recsel is required.") 
			if sim_seq == "n/p": error = 1; problems.append("Argument -ss/--sim-seq is required.") 
		else:
			if sim_mut == "n/p": error = 1; problems.append("Argument -sm/--sim-mut is required.")
			if sim_seq == "n/p": error = 1; problems.append("Argument -ss/--sim-seq is required.")
		
		#Check sim_mut ex: 40+e 
		if sim_mut != "n/p":
			
			# First of all, check that info provided is an integer
			try:

				# Try to convert the user input into an integer to determine if it is a number
				# This conversion also fails if the user types a float because python parses it as string
				# So, with this single line it can be determined if input is an integer
				int(sim_mut)

				# Calculate the ratio between reference bases and mutations
				mut_per_mb = int(sim_mut) / (float(genome_length) / 1000000)

				if workflow == "snp":
					#Check that number of mutations is < 100 / Mb
					if mut_per_mb > 100.0:
						error = 1; problems.append("Argument -sm/--sim-mut: the number of EMS SNPs to create is over the maximum allowed (100/Mb).")
					sim_mut = sim_mut + "+e"		
				if workflow == "ins":
					#Check that number of mutations is < 1 / Mb
					if mut_per_mb > 1.0:
						error = 1; problems.append("Argument -sm/--sim-mut: the number of insertions to create is over the maximum allowed (1/Mb).")
					sim_mut = sim_mut + "+li"

			except ValueError:
				error = 1
				problems.append("Argument -sm/--sim-mut: the information provided is not an integer.")


			# Deprecated
			'''
			try:
				values = sim_mut.split("+")
				if len(values) == 2:
					number = int(values[0])
					options = ["e", "d","li"]
					if values[1] not in options and workflow == "snp":
						error = 1
						problems.append("The parameter --sim_mut / -sm requires a second parameter that has to be <  e  > if the mode is EMS mutations or <  d  > if the mode is drift mutations")
						if values[1] == "li":
							error = 1
							problems.append("The parameter --sim_mut / -sm requires a second parameter that has to be <  li  > in insertion mode. A non-defined parameter is also accepted")	
				elif len(values) == 1 and workflow == "ins":
					number = int(values[0])
					sim_mut = sim_mut+"+li"

				else:
					error = 1	
					problems.append("The parameter --sim_mut / -sm requires more arguments. Number_of_mutations(+mode)*     *Only required in snp mode, in insertion mode it is not needed. ee the documentation (--usage)(-u) in order to obtain more information regarding this format. ")
			except:
				error = 1
				problems.append("Please mind the format of --sim_mut / -sm: number_of_mutations+mode  where number_of_mutations is any positive number and mode has to be chosen between e (EMS) and d (drift). See the documentation (--usage)(-u) in order to obtain more information regarding this format.")
			'''

		if sim_recsel != "n/p" and workflow == "snp":
			
			# Calculate the number of contigs in the reference genome
			number_of_contigs = len(ref_seq_stats)

			#0,14-1,31-2,33-3,15-4,5-5,2/0,24;1,42;2,25;3,6;4,1;5,1+1,10000000+50
			try: 
				values = sim_recsel.split("+")
				if len(values) == 3:
					
					# Check parameter 1 (recombination frequency distributions)
					chromo = values[0].split("/")

					if len(chromo) != number_of_contigs:
						error = 1
						problems.append("Argument -sr/--sim-recsel: the first parameter provided has an incorrect format (the number of recombination frequency lists does not match the number of contigs in the reference sequence).")
					already = 0
					for ch in chromo:
						c = ch.split("-")
						for v in c: 
							v = v.split(",")
						
							if v[0] == "" or v[1] == "":
								if already != 1:
									already = 1
									error = 1; problems.append("Argument -sr/--sim-recsel: the first parameter provided has an incorrect format.")

							if len(v) != 2:
								if already != 1:
									already = 1
									error = 1; problems.append("Argument -sr/--sim-recsel: the first parameter provided has an incorrect format.")

					# Check parameter 2 (contig,position of the causal mutation)
					val = values[1].split("-")
					for mutations in val:           # Loop though val because it can contain 2 mutations (first and second site mutations)
						val1 = mutations.split(",")
						causalmut_contig = int(val1[0])
						causalmut_position = int(val1[1])
						if causalmut_contig > len(ref_seq_stats):
							error = 1
							problems.append("Argument -sr/--sim-recsel: the second parameter refers to a contig not present in the reference sequence.")
						else:
							if int(ref_seq_stats[int(val1[0])-1]) < int(val1[1]): 
								error = 1
								problems.append("Argument -sr/--sim-recsel: the second parameter refers to a position not present in the contig specified.")

					# Check parameter 3 (number of recombinant chromosomes to generate)
					val = values[2]
					try:
						int(val)
					except:
						error = 1
						problems.append("Argument -sr/--sim-recsel: the third parameter provided is not an integer.")
					

					# Deprecated
					"""
					options = ["r", "d","dr"] 
					if values[2] not in options:
						error = 1
						problems.append("")	
					int(values[3])
					
					"""
					# Create sim_recsel string for easymap.sh
					# sim-recsel.py within easymap will only be used in r mode (recessive mutation). Therefore, there is no need to ask the user to specify the mode.
					sim_recsel = values[0] + "+" + values[1] + "+r+" + values[2]
					
				else:
					error =1
					problems.append("Argument -sr/--sim-recsel: the number of parameters provided is incorrect. It must be three.")
			except:
				error = 1
				problems.append("Argument -sr/--sim-recsel: the parameters provided have an incorrect format.")
		
		#sim_seq 1+100,0+500,100+1+50+se           
		if sim_seq != "n/p":

			try:
				params = sim_seq.split("+")

				if len(params) == 6:
					param1 = params[1].split(",")
					param2 = params[2].split(",")
					
					try: int(params[0])
					except: error = 1; problems.append("Argument -ss/--sim-seq: invalid choice in the 1st parameter. Use an integer.")
					try: int(param1[0]); int(param1[1])
					except: error = 1; problems.append("Argument -ss/--sim-seq: invalid choice in the 2nd parameter. Use an integer.") 
					try: int(param2[0]); int(param2[1])
					except: error = 1; problems.append("Argument -ss/--sim-seq: invalid choice in the 3rd parameter. Use an integer.") 
					try: int(params[3])
					except: error = 1; problems.append("Argument -ss/--sim-seq: invalid choice in the 4th parameter. Use an integer.")  
					try: int(params[4])
					except: error = 1; problems.append("Argument -ss/--sim-seq: invalid choice in the 5th parameter. Use an integer." )

					options = ("se","pe")
					params[5] = params[5].lower()
					if params[5] not in options:
						error = 1
						problems.append("Argument -ss/--sim-seq: invalid choice in the 6th parameter. Choose between 'se' and 'pe'.")
					else:			
						lib_type_sample = params[5]
						lib_type_control = params[5]

				else:
					error =1
					problems.append("Argument -ss/--sim-seq: the number of parameters provided is incorrect. It must be six.")

			except:
				error = 1
				problems.append("Argument -ss/--sim-seq: the parameters provided have an incorrect format.")

#If the user is providing its own data (not simulating reads), reads should be provided:
if data_source == "exp":
	if reads_sample == "n/p":
		error = 1
		problems.append("Argument -P/--reads-problem is required. Alternatively, you can use the -sim/--simulate-reads mode.")
	else:
		RS = reads_sample.split(",")
		if len(RS) == 1:
			lib_type_sample = "se" 
			read_s = reads_sample
		elif len(RS) == 2:
			lib_type_sample ="pe"
			read_f = RS[0]
			read_r= RS[1]

	# Check names of reads
	if lib_type_sample == "se":
		
		if reads_sample not in input_files:
			error = 1
			problems.append("Argument -P/--reads-problem: the name provided does not match any file in the directory /user_data.")	

	if lib_type_sample == "pe":
		
		if read_f not in input_files: 
			error = 1
			problems.append("Argument -P/--reads-problem: the name provided does not match any file in the directory /user_data.")
		
		if read_r not in input_files:
			error = 1
			problems.append("Argument -P/--reads-problem: the name provided does not match any file in the directory /user_data.")
		else:
			if read_f == read_r:
				error = 1
				problems.append("Argument -P/--reads-problem: the two names provided are identical.")

	# If snp mode, check control reads
	if workflow == "snp":
		
		if reads_control == "n/p":
			error = 1
			problems.append("Argument -C/--reads-control is required. Alternatively, you can use the -sim/--simulate-reads mode.")
		else:
			RC = reads_control.split(",") 
			if len(RC) == 1:
				lib_type_control = "se" 
				read_s_control = reads_control
			elif len(RC) == 2:
				lib_type_control ="pe"
				read_f_control = RC[0]
				read_r_control = RC[1]
		
		if lib_type_control == "pe":
			if read_f_control not in input_files:
				error = 1
				problems.append("Argument -C/--reads-control: the first name provided does not match any file in the directory /user_data.")
			if read_r_control not in input_files:
				error = 1
				problems.append("Argument -C/--reads-control: the second name provided does not match any file in the directory /user_data.")
			else:
				if read_f_control == read_r_control:
					error = 1
					problems.append("Argument -C/--reads-control: the two names provided are identical.")
		
		if lib_type_control == "se":
			if reads_control not in input_files:
				error = 1
				problems.append("Argument -C/--reads-control: the name provided does not match any file in the directory /user_data.")

		if reads_control == reads_sample:
			error = 1
			problems.append("The same name was provided to arguments -P/--reads-problem and -C/--reads-control.")


#This code checks the configuration of the program. It calls allow-new-project.py and checks its result.
proc = subprocess.Popen("python allow-new-project.py", cwd=r'./config', shell=True, stdout=subprocess.PIPE)
script_response = proc.stdout.read()
response = script_response.split(",")
try:
	if int(response[0]) >= 100:
		error = 1; problems.append("The number of gigabytes in the folder /user_projects exceeds the maximum allowed in the config/config file ("+response[2].strip()+")")
except:
	error = 1; problems.append(response[0])
try:
	int(response[1])
	if int(response[1]) >= 100:
		error = 1; problems.append("The number of projects currently running exceeds the maximum allowed in the config/config file ("+response[3].strip()+") [Manually killed projects can be interpreted as running by easymap. This can be solved by removing the project folder]")
except:
	error = 1; problems.append(response[1])

if error == 1: 
	print "=======================================================\nCOMMAND ERROR. Please fix the following issues:"
	for items in problems:
		print "-" + items
	print generic_help_message
	print "======================================================="
	quit()	

# Run easymap.sh
                     # 1                    2                3                   4               5               6                7                8              9              10             11                      12                     13                     14                     15                       16                    17                 18                        19                       20              21                 22      
master_program_input = project_name + " " + workflow + " " + data_source + " " + ref_seq + " " + ins_seq + " " + gff_file + " " + ann_file + " " + read_s + " " + read_f + " " + read_r + " " + lib_type_sample + " " + read_s_control + " " + read_f_control + " " + read_r_control + " " + lib_type_control + " " + is_ref_strain + " " + cross_type + " " + snp_analysis_type + " " + control_parental + " " + sim_mut + " " + sim_recsel + " " + sim_seq

#print master_program_input

call("./easymap.sh " + master_program_input, shell=True)
