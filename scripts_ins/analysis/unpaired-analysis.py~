#This script creates a dictionary with the read depth of each read nucleotide in a sam file

import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-a', action="store", dest = 'input')
parser.add_argument('-b', action="store", dest = 'output')
args = parser.parse_args()


#Imput file and dictionary creation
input = str(args.input) 
f1 = open(input, 'r')
lines = f1.readlines()	
dict = {}

#Output file
f2 = open(str(args.output), 'w')

#Now we loop through the lines and split them
for i, line in enumerate(lines):
	if not line.startswith('@'):
		sp = line.split('\t')
		
		#Then we define the CIGAR parameter, from which we will extract the aligned nucleotides
		cigar = sp[5].strip()
		if cigar != '*':
		
			#The varialbe X will generate a list of each part of the CIGAR code
			#The variable l will contain the sum of the nucleotides aligned in the genome for each read
			x = '' 
			l = 0
			
			#The following lines read through the CIGAR separating by \t each letter
			for i in cigar: 
				if i == 'M' or i == 'D' or i == 'I' or i == 'N' or i == 'S' or i == 'H' or i == 'P' or i == 'X' : 
					x += str(i) + '\t'
				else:
					x += str(i)
			sp2 = x.split()
			
			#We read through the split X variable and perform the operations necesary to determine l:
			for i in sp2:
				if 'M' in i:
					num = i.replace('M', '')
					l = int(l) + int(num)
				if 'D' in i:
					num = i.replace('D', '')
					l = int(l) + int(num)
				if 'I' in i:
					num = i.replace('I', '')
					l = int(l) - int(num)
		#We determine the start and ending of an aligment and write in the dictionary the accumulated read depth 
		if sp[3] != '0':
			p = int(sp[3]) #Read position
			pf = p + int(l) - 1 #Final position
			for i in range(p,(pf+1)):
				try: 
					dict[i] =  1 + dict[i]
				except KeyError:
					dict[i] = 1

#Finally we sort the dictionary and write it to an output file
for key,value in sorted(dict.items()):
	f2.write(str(key) + '\t' + str(value) + '\n')



#The following module uses the flags of the sam file to differentiatie F and R reads, and then creates a candidate region for the insertion

input = str(args.input)
f1 = open(input, 'r')
lines = f1.readlines()	


flags = (2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0)

#Delimiters:
d1 = float('inf')
d2 = 0

for i, line in enumerate(lines):
	if not line.startswith('@'):
		sp = line.split('\t')
		f = int(sp[1])
		l=[]
		
		while f not in flags:
			for i in flags:
				if i <= f: 
					l.append(i)
					f = f - i 
					break
		else: 
			l.append(f)
			if 16 in l: #reverse
				p = int(sp[3])
				if p < d1: 
					d1 = p
				
			else: #forward
				p = int(sp[3]) #Read position
				l = len(sp[9])
				pf = p + int(l) - 1 #Final position
				if pf > d2:
					d2 = pf

print 'Your candidate region is [' + str(d1) + ', ' + str(d2) + ']'


